Урок 12. Реализация методов Insert, Emplace и Erase
Задание
Это последняя часть итогового проекта спринта. 
Сохраните решение на GitHub, чтобы сдать его на ревью.
Реализуйте методы Insert, Emplace и Erase в классе Vector, 
а также методы begin, cbegin, end и cend для получения итераторов на начало 
и конец вектора.
Сигнатура методов:

template <typename T>
class Vector {
public:
    using iterator = T*;
    using const_iterator = const T*;
    
    iterator begin() noexcept;
    iterator end() noexcept;
    const_iterator begin() const noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    template <typename... Args>
    iterator Emplace(const_iterator pos, Args&&... args);
    iterator Erase(const_iterator pos) /*noexcept(std::is_nothrow_move_assignable_v<T>)*/;
    iterator Insert(const_iterator pos, const T& value);
    iterator Insert(const_iterator pos, T&& value);
    ...
}; 

Методы Emplace и Erase, выполняя реаллокацию, должны перемещать элементы, 
а не копировать, если действительно любое из условий:
    - тип T имеет noexcept-конструктор перемещения;
    - тип T не имеет конструктора копирования.
Если при вставке происходит реаллокация, ожидается ровно Size() перемещений 
или копирований существующих элементов. Сам вставляемый элемент должен 
копироваться либо перемещаться в зависимости от версии метода Insert.

Вызов Insert и Emplace, не требующий реаллокации, должен перемещать ровно 
end()-pos существующих элементов плюс одно перемещение элемента из временного 
объекта в вектор.
Методы Insert и Emplace при вставке элемента в конец вектора должны обеспечивать 
строгую гарантию безопасности исключений, когда выполняется любое из условий:
    - шаблонный параметр T имеет конструктор копирования;
    - шаблонный параметр T имеет noexcept-конструктор перемещения.
Если ни одно из этих условий не выполняется либо элемент вставляется в середину 
или начало вектора, методы Insert и Emplace должны обеспечивать базовую гарантию 
безопасности исключений.
Метод Erase должен вызывать деструктор ровно одного элемента, а также вызывать 
оператор присваивания столько раз, сколько элементов находится в векторе следом 
за удаляемым элементом. Итератор pos, который задаёт позицию удаляемого элемента, 
должен указывать на существующий элемент вектора. Передача в метод Erase 
итератора end(), невалидного итератора или итератора, полученного у другого вектора, 
приводит к неопределённому поведению.

